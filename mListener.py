# Module mListener.py
from __future__ import print_function
import socket
import re, hashlib, time, collections, sys
import threading
from mMessage import mMessage


class mListenerThread(threading.Thread):

    def __init__(self, config):
        threading.Thread.__init__(self)
        self.setDaemon(True)

        self.config = config

        # Replay attack protection
        # Check the last 1,000 validated messages to ensure
        # that we don't process a re-transmitted message
        self.REPLAY_LIST = collections.deque([], 1000)
        self.replayAttempts = 0

        self.start()


    # Function to allow printing to stderr
    # http://stackoverflow.com/questions/5574702/how-to-print-to-stderr-in-python
    @staticmethod
    def eprint(*args, **kwargs):
        print(*args, file=sys.stderr, **kwargs)


    def getReplayAttempts(self):
        return self.replayAttempts


    # Validate the message we received was generated by a trusted source
    def validateDigest(self, givenDigest, entropy, counter, data):
        newDigest = hashlib.sha256( \
          self.config['SHARED_KEY'] \
          +str(entropy) \
          +str(counter) \
          +str(data) \
          ).hexdigest()

        return (givenDigest == newDigest)


    # Validate the message we received was not retransmitted
    # True is good, means no replay found
    # Don't add the new info here to REPLAY_LIST
    def checkReplay(self, entropy, counter):
        for val in self.REPLAY_LIST:
            if val == str(entropy)+str(counter):
                return False

        return True


    def run(self):
        config = self.config

        # Create a UDP socket
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)

        # Allow multiple sockets to use the same PORT number
        sock.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)

        # Bind to the port that we know will receive multicast data
        sock.bind((config['ANY'],config['MCAST_PORT']))

        # Tell the kernel that we want to add ourselves to a multicast group
        # The address for the multicast group is the third param
        status = sock.setsockopt(socket.IPPROTO_IP,
        socket.IP_ADD_MEMBERSHIP,
        socket.inet_aton(config['MCAST_GRP']) + socket.inet_aton(config['ANY']))

        # setblocking(0) is equiv to settimeout(0.0) which means we poll the socket.
        # But this will raise an error if recv() or send() can't immediately find or send data.
        sock.setblocking(0)

        while 1:
            try:
                time.sleep(0.1)
                data, addr = sock.recvfrom(10240)
            except socket.error as e:
                pass
            else:
                # Extract components of a message
                match = re.search('^([a-zA-Z0-9]*)\n([a-zA-Z0-9]*)\n([0-9]*)\n(.*)', data, re.DOTALL)

                if match.lastindex == None:
                    pass
                else:
                    m = mMessage()
                    m.setDigest( match.group(1) )
                    m.setEntropy( match.group(2) )
                    m.setCounter( match.group(3) )
                    m.setData( match.group(4) )

                    hashvalid = self.validateDigest(m.getDigest(), m.getEntropy(), m.getCounter(), m.getData())
                    noreplay = self.checkReplay(m.getEntropy(), m.getCounter())

                    if config['DEBUG']:
                        self.eprint("From: ", addr)
                        self.eprint("Num matches: ", match.lastindex)
                        self.eprint("Digest: ", m.getDigest())
                        self.eprint("Entropy: ", m.getEntropy())
                        self.eprint("Transmission counter: ", str(m.getCounter()))
                        self.eprint("Valid digest: ", "Yes" if hashvalid else "No")
                        self.eprint("Not replayed: ", "Yes" if noreplay else "No")
                        self.eprint("Data: ", str(m.getData()))

                    if not hashvalid or not noreplay:
                        #eprint("Bad transmission")

                        if not noreplay:
                            self.replayAttempts = self.replayAttempts+1

                    else:
                        # Add the 'replay' info to the list here; now we know
                        # the basic information is valid (don't do it before validating
                        # the digest so no one can poison the validation, and don't do
                        # it before checking for a replay so we don't re-add the same
                        # information multiple times)
                        self.REPLAY_LIST.append( m.getMessageID() )

                        # Add the valid message to the queue for processing
                        # by other threads
                        # print("Good transmission")
                        config['q'].put(m)
